// EMERGENCY AUDIO MIXER REPAIR SCRIPT\n// üöÄ Run in Browser Console: emergencyRepair.fixEverything()\n\nwindow.emergencyRepair = {\n  \n  // üö® SOFORTIGE REPARATUR ALLER PROBLEME\n  async fixEverything() {\n    console.log('üö® === EMERGENCY AUDIO MIXER REPAIR STARTED ===');\n    \n    const results = {\n      serviceManager: await this.fixServiceManager(),\n      obsConnection: await this.fixOBSConnection(),\n      audioSources: await this.fixAudioSources(),\n      audioDeckWidgets: await this.fixAudioDeckWidgets(),\n      midiLearning: this.fixMIDILearning()\n    };\n    \n    console.log('üìä REPAIR RESULTS:', results);\n    \n    // Final test\n    setTimeout(() => {\n      if (window.diagnosticScript) {\n        window.diagnosticScript.runFullDiagnosis();\n      }\n    }, 3000);\n    \n    return results;\n  },\n  \n  // 1. Service Manager reparieren\n  async fixServiceManager() {\n    console.log('üîß Fixing ServiceManager...');\n    \n    if (!window.serviceManager) {\n      console.error('‚ùå ServiceManager not available!');\n      return false;\n    }\n    \n    if (!window.serviceManager.initialized) {\n      try {\n        console.log('üöÄ Initializing ServiceManager...');\n        const success = await window.serviceManager.initializeAllServices();\n        if (success) {\n          console.log('‚úÖ ServiceManager initialized successfully');\n          return true;\n        } else {\n          console.warn('‚ö†Ô∏è ServiceManager partially initialized');\n          return 'partial';\n        }\n      } catch (error) {\n        console.error('‚ùå ServiceManager initialization failed:', error);\n        return false;\n      }\n    } else {\n      console.log('‚úÖ ServiceManager already initialized');\n      return true;\n    }\n  },\n  \n  // 2. OBS Verbindung reparieren\n  async fixOBSConnection() {\n    console.log('üîß Fixing OBS Connection...');\n    \n    try {\n      if (window.globalStateService?.isOBSConnected?.()) {\n        console.log('‚úÖ OBS already connected');\n        return true;\n      }\n      \n      if (window.serviceManager) {\n        console.log('üîó Connecting to OBS via ServiceManager...');\n        const connected = await window.serviceManager.connectToOBS('localhost', 4455, '');\n        if (connected) {\n          console.log('‚úÖ OBS connected successfully via ServiceManager');\n          return true;\n        }\n      }\n      \n      // Fallback: Direct connection\n      if (window.globalStateService?.services?.obs) {\n        console.log('üîó Attempting direct OBS connection...');\n        await window.globalStateService.services.obs.connect('localhost', 4455, '');\n        return true;\n      }\n      \n      console.warn('‚ö†Ô∏è OBS connection failed - check if OBS is running with WebSocket enabled');\n      return false;\n      \n    } catch (error) {\n      console.error('‚ùå OBS connection error:', error);\n      return false;\n    }\n  },\n  \n  // 3. Audio Sources reparieren\n  async fixAudioSources() {\n    console.log('üîß Fixing Audio Sources...');\n    \n    try {\n      const obsService = window.globalStateService?.services?.obs;\n      if (!obsService) {\n        console.error('‚ùå OBS Service not available');\n        return false;\n      }\n      \n      if (!obsService.isConnected()) {\n        console.warn('‚ö†Ô∏è OBS not connected, cannot discover sources');\n        return false;\n      }\n      \n      console.log('üîç Discovering audio sources...');\n      await obsService.discoverAudioSources();\n      \n      // Wait for sources to be discovered\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n      const sources = window.globalStateService.getAudioSources();\n      console.log('‚úÖ Audio sources discovered:', sources.length);\n      \n      if (sources.length > 0) {\n        sources.forEach(source => {\n          console.log(`  - ${source.name} (${source.kind})`);\n        });\n        return true;\n      } else {\n        console.warn('‚ö†Ô∏è No audio sources found');\n        return false;\n      }\n      \n    } catch (error) {\n      console.error('‚ùå Audio sources discovery failed:', error);\n      return false;\n    }\n  },\n  \n  // 4. Audio Deck Widgets reparieren\n  async fixAudioDeckWidgets() {\n    console.log('üîß Fixing Audio Deck Widgets...');\n    \n    try {\n      if (!window.audioDeckService) {\n        console.error('‚ùå AudioDeckService not available');\n        return false;\n      }\n      \n      const decks = window.audioDeckService.getAllDecks();\n      console.log('üìä Found', decks.length, 'audio decks');\n      \n      if (decks.length === 0) {\n        console.log('üèóÔ∏è Creating default audio deck...');\n        \n        const sources = window.globalStateService?.getAudioSources?.() || [];\n        const sourceNames = sources.map(s => s.name);\n        \n        if (sourceNames.length > 0) {\n          const newDeck = window.audioDeckService.createAudioDeck({\n            name: 'Main Audio',\n            description: 'Emergency created deck',\n            color: 'blue',\n            sources: sourceNames.slice(0, 3) // First 3 sources\n          });\n          \n          if (newDeck) {\n            console.log('‚úÖ Created emergency audio deck:', newDeck.name);\n            return true;\n          }\n        }\n      }\n      \n      // Trigger widget refresh\n      window.dispatchEvent(new CustomEvent('audioDeckRefresh'));\n      console.log('üîÑ Triggered audio deck widget refresh');\n      \n      return true;\n      \n    } catch (error) {\n      console.error('‚ùå Audio deck widgets repair failed:', error);\n      return false;\n    }\n  },\n  \n  // 5. MIDI Learning reparieren\n  fixMIDILearning() {\n    console.log('üîß Fixing MIDI Learning...');\n    \n    try {\n      // Stop any existing learning\n      if (window.globalStateService?.stopMIDILearning) {\n        window.globalStateService.stopMIDILearning();\n      }\n      \n      // Reset MIDI state\n      if (window.globalStateService?.updateMIDIState) {\n        window.globalStateService.updateMIDIState({\n          learning: false,\n          learningTarget: null\n        });\n      }\n      \n      console.log('‚úÖ MIDI Learning state reset');\n      return true;\n      \n    } catch (error) {\n      console.error('‚ùå MIDI Learning repair failed:', error);\n      return false;\n    }\n  },\n  \n  // üß™ Test OBS Functions\n  async testOBSFunctions() {\n    console.log('üß™ Testing OBS Functions...');\n    \n    const obsService = window.globalStateService?.services?.obs;\n    if (!obsService || !obsService.isConnected()) {\n      console.error('‚ùå OBS not connected');\n      return false;\n    }\n    \n    try {\n      // Test source discovery\n      await obsService.discoverAudioSources();\n      const sources = obsService.getAudioSources();\n      console.log('‚úÖ Source discovery test passed:', sources.length, 'sources');\n      \n      // Test volume control\n      if (sources.length > 0) {\n        const testSource = sources[0];\n        const originalVolume = testSource.volumeDb;\n        \n        console.log('üéöÔ∏è Testing volume control with:', testSource.name);\n        \n        // Set to -30dB\n        await obsService.setVolume(testSource.name, -30);\n        await new Promise(resolve => setTimeout(resolve, 500));\n        \n        // Restore original\n        await obsService.setVolume(testSource.name, originalVolume);\n        \n        console.log('‚úÖ Volume control test passed');\n      }\n      \n      return true;\n      \n    } catch (error) {\n      console.error('‚ùå OBS function test failed:', error);\n      return false;\n    }\n  },\n  \n  // üß™ Test MIDI Functions\n  testMIDIFunctions() {\n    console.log('üß™ Testing MIDI Functions...');\n    \n    const midiService = window.globalStateService?.services?.midi;\n    if (!midiService) {\n      console.warn('‚ö†Ô∏è MIDI Service not available');\n      return false;\n    }\n    \n    try {\n      // Test MIDI learning\n      console.log('üéπ Testing MIDI Learning...');\n      const success = midiService.startLearning((message) => {\n        console.log('‚úÖ MIDI Learning test passed:', message);\n        midiService.stopLearning();\n      });\n      \n      if (success) {\n        console.log('üéπ MIDI Learning active - move a MIDI control or press Q-K keys...');\n        \n        // Auto-stop after 10 seconds\n        setTimeout(() => {\n          midiService.stopLearning();\n          console.log('üõë MIDI Learning test timeout');\n        }, 10000);\n        \n        return true;\n      } else {\n        console.warn('‚ö†Ô∏è MIDI Learning could not be started');\n        return false;\n      }\n      \n    } catch (error) {\n      console.error('‚ùå MIDI function test failed:', error);\n      return false;\n    }\n  },\n  \n  // üìä Status Check\n  getSystemStatus() {\n    const status = {\n      serviceManager: {\n        available: !!window.serviceManager,\n        initialized: window.serviceManager?.initialized || false\n      },\n      obs: {\n        serviceAvailable: !!window.globalStateService?.services?.obs,\n        connected: window.globalStateService?.isOBSConnected?.() || false,\n        sourcesCount: window.globalStateService?.getAudioSources?.()?.length || 0\n      },\n      midi: {\n        serviceAvailable: !!window.globalStateService?.services?.midi,\n        connected: window.globalStateService?.isMIDIConnected?.() || false\n      },\n      audioDecks: {\n        serviceAvailable: !!window.audioDeckService,\n        decksCount: window.audioDeckService?.getAllDecks?.()?.length || 0\n      },\n      diagnostic: {\n        available: !!window.diagnosticScript\n      }\n    };\n    \n    console.log('üìä System Status:', status);\n    return status;\n  },\n  \n  // üîÑ Force Refresh Everything\n  forceRefreshAll() {\n    console.log('üîÑ Force refreshing all components...');\n    \n    // Trigger various refresh events\n    window.dispatchEvent(new CustomEvent('audioMixerRefresh'));\n    window.dispatchEvent(new CustomEvent('audioDeckRefresh'));\n    window.dispatchEvent(new CustomEvent('dashboardRefresh'));\n    \n    // Force OBS source discovery\n    if (window.globalStateService?.services?.obs?.discoverAudioSources) {\n      window.globalStateService.services.obs.discoverAudioSources();\n    }\n    \n    console.log('‚úÖ Refresh events dispatched');\n  },\n  \n  // üÜò Nuclear Option - Complete Reset\n  async nuclearReset() {\n    console.log('üÜò NUCLEAR RESET - This will reset everything!');\n    \n    try {\n      // Clear localStorage\n      localStorage.removeItem('unifiedGlobalMappings');\n      localStorage.removeItem('midiMappings');\n      localStorage.removeItem('dashboardHotkeyMappings');\n      \n      // Reset services\n      if (window.serviceManager?.destroy) {\n        window.serviceManager.destroy();\n      }\n      \n      // Force page reload after short delay\n      console.log('üîÑ Page will reload in 3 seconds...');\n      setTimeout(() => {\n        location.reload();\n      }, 3000);\n      \n      return true;\n      \n    } catch (error) {\n      console.error('‚ùå Nuclear reset failed:', error);\n      return false;\n    }\n  }\n};\n\n// Auto-run status check\nconsole.log('üö® Emergency Audio Mixer Repair Tool loaded!');\nconsole.log('üöÄ Quick Commands:');\nconsole.log('   emergencyRepair.fixEverything() - Fix all problems');\nconsole.log('   emergencyRepair.getSystemStatus() - Check system status');\nconsole.log('   emergencyRepair.testOBSFunctions() - Test OBS');\nconsole.log('   emergencyRepair.testMIDIFunctions() - Test MIDI');\nconsole.log('   emergencyRepair.nuclearReset() - Complete reset (last resort)');\nconsole.log('');\n\n// Auto-check status\nemergencyRepair.getSystemStatus();\n\nexport default window.emergencyRepair;\n