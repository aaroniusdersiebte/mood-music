// Audio Mixer Diagnose- und Reparatur-Skript
// Ausf√ºhren in der Browser-Konsole: diagnosticScript.runFullDiagnosis()

window.diagnosticScript = {
  
  // Hauptdiagnose-Funktion
  async runFullDiagnosis() {
    console.log('üîß === AUDIO MIXER DIAGNOSE GESTARTET ===');
    
    const results = {
      serviceManager: await this.checkServiceManager(),
      globalStateService: this.checkGlobalStateService(),
      obsService: this.checkOBSService(),
      midiService: this.checkMIDIService(),
      audioDeckService: this.checkAudioDeckService(),
      connections: this.checkConnections(),
      audioSources: this.checkAudioSources()
    };
    
    console.log('üìä === DIAGNOSE-ERGEBNISSE ===');
    console.table(results);
    
    // Automatische Reparatur-Vorschl√§ge
    this.suggestRepairs(results);
    
    return results;
  },

  // Service Manager Check
  async checkServiceManager() {
    const status = {
      available: !!window.serviceManager,
      initialized: window.serviceManager?.initialized || false,
      serviceStates: window.serviceManager?.serviceStates || {}
    };
    
    if (!status.available) {
      console.error('‚ùå ServiceManager nicht verf√ºgbar!');
      console.log('üí° L√∂sung: App neu laden oder ServiceManager importieren');
    } else if (!status.initialized) {
      console.warn('‚ö†Ô∏è ServiceManager nicht initialisiert!');
      console.log('üí° L√∂sung: Warte auf App-Initialisierung oder rufe serviceManager.initializeAllServices() auf');
    } else {
      console.log('‚úÖ ServiceManager OK');
    }
    
    return status;
  },

  // Global State Service Check
  checkGlobalStateService() {
    const status = {
      available: !!window.globalStateService,
      obsConnected: window.globalStateService?.isOBSConnected?.() || false,
      midiConnected: window.globalStateService?.isMIDIConnected?.() || false,
      sourcesCount: window.globalStateService?.getAudioSources?.()?.length || 0,
      mappingsCount: Object.keys(window.globalStateService?.getAudioSourceMappings?.() || {}).length
    };
    
    if (!status.available) {
      console.error('‚ùå GlobalStateService nicht verf√ºgbar!');
    } else {
      console.log('‚úÖ GlobalStateService verf√ºgbar');
      console.log('üìä Status:', status);
    }
    
    return status;
  },

  // OBS Service Check
  checkOBSService() {
    const globalState = window.globalStateService;
    const obsService = globalState?.services?.obs;
    
    const status = {
      available: !!obsService,
      connected: obsService?.isConnected?.() || false,
      sourcesCount: obsService?.getAudioSources?.()?.length || 0,
      methodsAvailable: {
        connect: typeof obsService?.connect === 'function',
        discoverAudioSources: typeof obsService?.discoverAudioSources === 'function',
        setVolume: typeof obsService?.setVolume === 'function',
        toggleMute: typeof obsService?.toggleMute === 'function'
      }
    };
    
    if (!status.available) {
      console.error('‚ùå OBS Service nicht verf√ºgbar!');
    } else if (!status.connected) {
      console.warn('‚ö†Ô∏è OBS nicht verbunden!');
    } else {
      console.log('‚úÖ OBS Service OK');
    }
    
    return status;
  },

  // MIDI Service Check
  checkMIDIService() {
    const globalState = window.globalStateService;
    const midiService = globalState?.services?.midi;
    
    const status = {
      available: !!midiService,
      methodsAvailable: {
        startLearning: typeof midiService?.startLearning === 'function',
        stopLearning: typeof midiService?.stopLearning === 'function',
        setMapping: typeof midiService?.setMapping === 'function'
      },
      mappingsCount: Object.keys(midiService?.getAllMappings?.() || {}).length
    };
    
    if (!status.available) {
      console.warn('‚ö†Ô∏è MIDI Service nicht verf√ºgbar (optional)');
    } else {
      console.log('‚úÖ MIDI Service verf√ºgbar');
    }
    
    return status;
  },

  // Audio Deck Service Check
  checkAudioDeckService() {
    const status = {
      available: !!window.audioDeckService,
      initialized: window.audioDeckService?.initialized || false,
      decksCount: window.audioDeckService?.getAllDecks?.()?.length || 0
    };
    
    if (!status.available) {
      console.error('‚ùå AudioDeckService nicht verf√ºgbar!');
    } else if (!status.initialized) {
      console.warn('‚ö†Ô∏è AudioDeckService nicht initialisiert!');
    } else {
      console.log('‚úÖ AudioDeckService OK');
    }
    
    return status;
  },

  // Verbindungs-Check
  checkConnections() {
    const globalState = window.globalStateService;
    const obsState = globalState?.getOBSState?.() || {};
    const midiState = globalState?.getMIDIState?.() || {};
    
    const status = {
      obs: {
        connected: obsState.connected || false,
        sourcesCount: obsState.sources?.length || 0,
        lastDiscovery: obsState.lastSourceDiscovery || 0
      },
      midi: {
        connected: midiState.connected || false,
        learning: midiState.learning || false,
        lastActivity: midiState.lastActivity || null
      }
    };
    
    console.log('üîó Verbindungsstatus:', status);
    return status;
  },

  // Audio Sources Check
  checkAudioSources() {
    const globalState = window.globalStateService;
    const sources = globalState?.getAudioSources?.() || [];
    const levels = globalState?.getAllAudioLevels?.() || {};
    
    const status = {
      totalSources: sources.length,
      sourcesWithLevels: Object.keys(levels).length,
      sources: sources.map(s => ({
        name: s.name,
        kind: s.kind,
        volumeDb: s.volumeDb,
        muted: s.muted,
        hasLevels: !!levels[s.name]
      }))
    };
    
    console.log('üéµ Audio Sources:', status);
    return status;
  },

  // Reparatur-Vorschl√§ge
  suggestRepairs(results) {
    console.log('\nüîß === REPARATUR-VORSCHL√ÑGE ===');
    
    if (!results.serviceManager.available) {
      console.log('1. ‚ùå ServiceManager fehlt -> App neu laden');
    } else if (!results.serviceManager.initialized) {
      console.log('1. üîÑ ServiceManager initialisieren:');
      console.log('   await window.serviceManager.initializeAllServices()');
    }
    
    if (!results.connections.obs.connected) {
      console.log('2. üîó OBS verbinden:');
      console.log('   await window.serviceManager.connectToOBS("localhost", 4455, "")');
    }
    
    if (results.connections.obs.connected && results.audioSources.totalSources === 0) {
      console.log('3. üîç OBS Sources entdecken:');
      console.log('   await window.globalStateService.services.obs.discoverAudioSources()');
    }
    
    if (!results.midiService.available) {
      console.log('4. üéπ MIDI Service reparieren:');
      console.log('   √úberpr√ºfe midiService.js Import in serviceManager.js');
    }
    
    console.log('\n‚ú® Automatische Reparatur verf√ºgbar:');
    console.log('   diagnosticScript.autoRepair()');
  },

  // Automatische Reparatur
  async autoRepair() {
    console.log('üîß === AUTOMATISCHE REPARATUR GESTARTET ===');
    
    try {
      // 1. ServiceManager initialisieren
      if (window.serviceManager && !window.serviceManager.initialized) {
        console.log('üîÑ Initialisiere ServiceManager...');
        const success = await window.serviceManager.initializeAllServices();
        if (success) {
          console.log('‚úÖ ServiceManager initialisiert');
        } else {
          console.warn('‚ö†Ô∏è ServiceManager-Initialisierung teilweise fehlgeschlagen');
        }
      }
      
      // 2. OBS verbinden
      if (!window.globalStateService?.isOBSConnected?.()) {
        console.log('üîó Verbinde mit OBS...');
        const obsConnected = await window.serviceManager?.connectToOBS?.('localhost', 4455, '');
        if (obsConnected) {
          console.log('‚úÖ OBS verbunden');
          
          // 3. Sources entdecken
          setTimeout(async () => {
            console.log('üîç Entdecke Audio Sources...');
            await window.globalStateService.services.obs?.discoverAudioSources?.();
            console.log('‚úÖ Audio Sources entdeckt');
          }, 2000);
        } else {
          console.warn('‚ö†Ô∏è OBS-Verbindung fehlgeschlagen');
        }
      }
      
      console.log('‚úÖ Automatische Reparatur abgeschlossen');
      
      // Neue Diagnose nach Reparatur
      setTimeout(() => {
        this.runFullDiagnosis();
      }, 3000);
      
    } catch (error) {
      console.error('‚ùå Automatische Reparatur fehlgeschlagen:', error);
    }
  },

  // MIDI Test
  testMIDI() {
    console.log('üéπ === MIDI TEST ===');
    
    const midiService = window.globalStateService?.services?.midi;
    if (!midiService) {
      console.error('‚ùå MIDI Service nicht verf√ºgbar');
      return false;
    }
    
    console.log('üéØ Starte MIDI Learning Test...');
    const success = midiService.startLearning((message) => {
      console.log('‚úÖ MIDI Learning funktioniert!', message);
      midiService.stopLearning();
    });
    
    if (success) {
      console.log('üéπ Bewege jetzt einen MIDI-Controller oder dr√ºcke Q-K auf der Tastatur...');
    } else {
      console.error('‚ùå MIDI Learning konnte nicht gestartet werden');
    }
    
    return success;
  },

  // OBS Test
  async testOBS() {
    console.log('üé• === OBS TEST ===');
    
    const obsService = window.globalStateService?.services?.obs;
    if (!obsService) {
      console.error('‚ùå OBS Service nicht verf√ºgbar');
      return false;
    }
    
    if (!obsService.isConnected()) {
      console.error('‚ùå OBS nicht verbunden');
      return false;
    }
    
    console.log('üîç Teste OBS Funktionen...');
    
    // Test source discovery
    await obsService.discoverAudioSources();
    const sources = obsService.getAudioSources();
    console.log('‚úÖ Sources gefunden:', sources.length);
    
    // Test volume control with first source
    if (sources.length > 0) {
      const firstSource = sources[0];
      console.log('üîä Teste Volume Control mit:', firstSource.name);
      
      const originalVolume = firstSource.volumeDb;
      await obsService.setVolume(firstSource.name, -20);
      
      setTimeout(async () => {
        await obsService.setVolume(firstSource.name, originalVolume);
        console.log('‚úÖ Volume Control funktioniert');
      }, 1000);
    }
    
    return true;
  },

  // Audio Deck Test
  testAudioDecks() {
    console.log('üéõÔ∏è === AUDIO DECK TEST ===');
    
    if (!window.audioDeckService) {
      console.error('‚ùå AudioDeckService nicht verf√ºgbar');
      return false;
    }
    
    const decks = window.audioDeckService.getAllDecks();
    console.log('üìä Verf√ºgbare Decks:', decks.length);
    
    decks.forEach(deck => {
      console.log(`üéµ Deck: ${deck.name} (${deck.sources.length} sources)`);
    });
    
    return true;
  },

  // Event Test
  testEvents() {
    console.log('üì° === EVENT SYSTEM TEST ===');
    
    const globalState = window.globalStateService;
    if (!globalState) {
      console.error('‚ùå GlobalStateService nicht verf√ºgbar');
      return false;
    }
    
    // Test OBS events
    let obsEventReceived = false;
    globalState.on('obsStateChanged', (state) => {
      obsEventReceived = true;
      console.log('‚úÖ OBS Event empfangen:', state.connected ? 'connected' : 'disconnected');
    });
    
    // Test MIDI events
    let midiEventReceived = false;
    globalState.on('midiStateChanged', (state) => {
      midiEventReceived = true;
      console.log('‚úÖ MIDI Event empfangen:', state.connected ? 'connected' : 'disconnected');
    });
    
    // Test audio level events
    let audioEventReceived = false;
    globalState.on('audioLevelsUpdated', (data) => {
      if (!audioEventReceived) {
        audioEventReceived = true;
        console.log('‚úÖ Audio Level Event empfangen f√ºr:', data.sourceName);
      }
    });
    
    console.log('üì° Event Listeners registriert - teste jetzt Verbindungen...');
    return true;
  },

  // Debug Info
  showDebugInfo() {
    console.log('üêõ === DEBUG INFORMATIONEN ===');
    
    const info = {
      window: {
        serviceManager: !!window.serviceManager,
        globalStateService: !!window.globalStateService,
        audioDeckService: !!window.audioDeckService,
        useMoodStore: !!window.useMoodStore
      },
      globalState: window.globalStateService ? {
        obsState: window.globalStateService.getOBSState(),
        midiState: window.globalStateService.getMIDIState(),
        services: Object.keys(window.globalStateService.services || {})
      } : null,
      serviceManager: window.serviceManager ? {
        initialized: window.serviceManager.initialized,
        serviceStates: window.serviceManager.serviceStates
      } : null
    };
    
    console.log('üìä System Info:', info);
    return info;
  }
};

// Auto-run bei Laden
console.log('üîß Audio Mixer Diagnose-Tool geladen!');
console.log('üöÄ Vollst√§ndige Diagnose: diagnosticScript.runFullDiagnosis()');
console.log('üîß Automatische Reparatur: diagnosticScript.autoRepair()');
console.log('üéπ MIDI Test: diagnosticScript.testMIDI()');
console.log('üé• OBS Test: diagnosticScript.testOBS()');
console.log('üêõ Debug Info: diagnosticScript.showDebugInfo()');
